# Asari シェル - 仕様書

## 概要

Asariは学習目的で開発されるモダンなコマンドラインシェルである。
Rustの構文や型システムから影響を受けた設計を採用する。

---

# リテラル仕様

## リテラルの種類

### 1. ダブルクォート文字列

**構文**: `"..."`

**特徴**:

- エスケープシーケンスが有効
- 複数行の文字列を記述可能

**例**:

```
"hello world"
"line1\nline2"
"path: \~not_expanded"
```

### 2. シングルクォート文字列

**構文**: `'...'`

**特徴**:

- エスケープシーケンスが有効
- ダブルクォート文字列と同等の機能

**例**:

```
'hello world'
'it\'s a test'
```

### 3. Raw文字列

**構文**: `r"..."` または `r#"..."#`

**特徴**:

- エスケープシーケンスが無効（バックスラッシュはそのまま保持）
- `#`の数を増やすことで、文字列内に`"`や`"#`を含めることが可能
- 開始と終了の`#`の数は一致する必要がある

**例**:

```
r"C:\Users\name"           → C:\Users\name
r#"say "hello""#           → say "hello"
r##"contains "#""##        → contains "#"
```

### 4. パスリテラル

**構文**: `p"..."` または `p#"..."#`

**特徴**:

- エスケープシーケンスが無効
- 評価時にチルダ展開とグロブ展開が行われる
- `#`の扱いはRaw文字列と同様

**例**:

```
p"~/Documents"             → /home/user/Documents（評価時に展開）
p"~user/files"             → /home/user/files（評価時に展開）
p"/home/*.txt"             → マッチするファイル一覧（評価時に展開）
p#"C:\Users\*"#            → Windowsパス対応
```

### 5. クォートなし文字列

**構文**: 特殊文字・空白を含まない文字列

**特徴**:

- エスケープシーケンスが無効
- 特殊文字または空白文字で終了する
- チルダ展開・グロブ展開は行わない

**例**:

```
hello                      → hello
hello-world                → hello-world
/usr/bin/python            → /usr/bin/python
```

## エスケープシーケンス

Rustと同じ仕様。
ダブルクォート文字列およびシングルクォート文字列内で有効。

| シーケンス | 意味                  | 文字コード |
| ---------- | --------------------- | ---------- |
| `\n`       | 改行                  | U+000A     |
| `\r`       | キャリッジリターン    | U+000D     |
| `\t`       | 水平タブ              | U+0009     |
| `\0`       | ヌル文字              | U+0000     |
| `\\`       | バックスラッシュ      | U+005C     |
| `\"`       | ダブルクォート        | U+0022     |
| `\'`       | シングルクォート      | U+0027     |
| `\u{XXXX}` | Unicodeコードポイント | 指定値     |

### Unicodeエスケープ

- 形式: `\u{X}` から `\u{XXXXXX}`（1〜6桁の16進数）
- 有効範囲: U+0000 〜 U+10FFFF（サロゲートペアU+D800〜U+DFFFを除く）
- 無効なコードポイントはパースエラー

**例**:

```
"\u{41}"        → A
"\u{3042}"      → あ
"\u{1F600}"     → 😀
```

## 特殊文字

クォートなし文字列を終了させる文字:

| 文字     | 用途                            |
| -------- | ------------------------------- |
| 空白文字 | 引数区切り（Unicode空白を含む） |
| `#`      | コメント開始                    |
| `$`      | 環境変数開始 / コマンド展開     |
| `%`      | シェル変数開始                  |
| `(` `)`  | 式 / コマンド展開               |
| `{` `}`  | コマンドグループ / サブシェル   |
| `\|`     | パイプ                          |
| `>` `<`  | リダイレクト                    |
| `;`      | コマンド区切り                  |
| `&`      | バックグラウンド実行（予約）    |

## 文字列の連結

リテラル同士の直接連結は許可しない。
連結には式構文を使用する。

```
# 無効
"hello"'world'

# 有効
("hello" + 'world')
```

## パース優先順位

`word`のパース時、以下の順序で試行する:

1. `$` → 環境変数
2. `%` → シェル変数
3. `'` → シングルクォート文字列
4. `"` → ダブルクォート文字列
5. `r` → Raw文字列を試行、失敗時はクォートなし文字列
6. `p` → パスリテラルを試行、失敗時はクォートなし文字列
7. その他 → クォートなし文字列

## エラー条件

| 状況                        | 動作                                   |
| --------------------------- | -------------------------------------- |
| 閉じられていないクォート    | 未定義（現状はクォートなしとして解析） |
| 無効なエスケープシーケンス  | パースエラー                           |
| 無効なUnicodeコードポイント | パースエラー                           |

---

# 変数仕様

## 概要

Asariでは環境変数とシェル変数を明確に区別する。

| 種類         | 接頭辞 | スコープ               | 継承       |
| ------------ | ------ | ---------------------- | ---------- |
| 環境変数     | `$`    | プロセス間で共有       | 子プロセス |
| シェル変数   | `%`    | シェルプロセス内のみ   | なし       |

## 変数名の規則

Rustの識別子規則に準拠する（Unicode Standard Annex #31）。

**形式**:
- `XID_Start XID_Continue*`
- `_ XID_Continue+`（アンダースコア単体は不可）

**有効な例**:

```
$PATH
$my_var
$変数
$カウンタ
%_private
%counter2
```

**無効な例**:

```
$2var          # 数字開始
$_             # アンダースコア単体
$my-var        # ハイフン不可
```

**補足**:
- 大文字小文字は区別する
- ひらがな、カタカナ、漢字等のUnicode文字を許可
- 識別子はNFC（Normalization Form C）で正規化される

## 環境変数

### 参照

環境変数の参照は常に`option<string>`型を返す。

| 構文 | 意味 | 戻り値の型 |
| ---- | ---- | ---------- |
| `$VAR` | 参照 | `option<string>` |
| `$VAR?` | unwrap（存在しなければエラー） | `string` |
| `$VAR ^ default` | unwrap_or（存在しなければデフォルト値） | `string` |
| `$#VAR` | 文字列長（存在しなければエラー） | `int` |
| `$?VAR` | 存在確認 | `bool` |

**例**:

```
echo $PATH?                    # 存在しなければエラー
echo $EDITOR ^ "vim"           # なければ "vim"
echo $EDITOR^"vim"             # スペースなしも可
```

### 代入

```
$VAR = "value"                 # 新規作成または更新（自動的にsome()でラップ）
$VAR = none                    # 削除
```

### 一時的な環境変数

コマンド実行時のみ有効な環境変数は`:=`で設定する。

```
$VAR := "temp" command arg1 arg2
```

## シェル変数

### 参照

シェル変数は宣言時の型を保持する。

| 構文 | 意味 |
| ---- | ---- |
| `%VAR` | 参照（変数の型） |
| `%VAR?` | Option型のunwrap |
| `%VAR ^ default` | Option型のunwrap_or |
| `%#VAR` | 長さ（文字列長または配列要素数） |
| `%?VAR` | 存在確認（`bool`） |

### 代入

```
%VAR = value                   # 型推論
%VAR: type = value             # 型明示
%VAR = none                    # Option型に none を代入、または変数削除
```

### 型明示

型推論できない場合（空配列など）は型明示が必須。

```
%nums: array<int> = []         # 空の整数配列
%result: option<string> = none # 明示的なOption型
```

## 特殊変数

| 変数 | 型 | 意味 |
| ---- | -- | ---- |
| `$?` | `int` | 直前コマンドの終了ステータス |
| `$$` | `int` | シェル自身のPID |
| `$!` | `option<int>` | 最後のバックグラウンドジョブのPID |
| `$@` | `string` | シェル名またはスクリプト名 |

**補足**:
- スクリプト引数は通常の関数引数として受け取る（後述）
- `$0`〜`$9`、`$#`単体、`$*`は使用しない

## 型システム

### 基本型

| 型名 | 説明 | リテラル例 |
| ---- | ---- | ---------- |
| `string` | 文字列 | `"hello"`, `'world'` |
| `int` | 整数（64bit） | `42`, `-1` |
| `float` | 浮動小数点（64bit） | `3.14`, `-0.5` |
| `bool` | 真偽値 | `true`, `false` |
| `path` | パス文字列 | `p"~/Documents"` |
| `unit` | ユニット型 | （代入式の戻り値など） |

### 複合型

| 型名 | 説明 | リテラル例 |
| ---- | ---- | ---------- |
| `array<T>` | 配列（同一型） | `[1, 2, 3]` |
| `option<T>` | Option型 | `some(42)`, `none` |

### 型リテラル

括弧内では型推論が行われる。

```
(42)           # int
(4.2)          # float
("hello")      # string
(true)         # bool
([1, 2, 3])    # array<int>
(some(42))     # option<int>
(none)         # option<unknown>（型明示が必要な場合あり）
```

クォートなしの場合は常に`string`として扱われる。

```
%x = 42        # string "42"
%x = (42)      # int 42
```

### 型変換

異なる型間の暗黙変換は行わない。明示的な変換が必要。

```
(42 as string)         # "42"
(4.2 as int)           # 4（切り捨て）
("42" as int)          # 42（パース失敗時はエラー）
(p"~/file" as string)  # 展開後の文字列
```

### 整数と小数の演算

整数と小数の混合演算は禁止。型変換を明示する。

```
# エラー
(1 + 1.5)

# 正しい
((1 as float) + 1.5)
(1 + (1.5 as int))
```

## 配列

### リテラル

```
[1, 2, 3]              # array<int>
["a", "b", "c"]        # array<string>
[]                     # エラー（型明示が必要）
```

### 要素アクセス

```
%nums[0]               # 最初の要素（option<T>）
%nums[-1]              # 最後の要素（option<T>）
%nums[100]             # 範囲外（none）
```

### 要素更新

```
%nums[0] = 10          # 最初の要素を更新
```

### 配列操作

```
%nums + 7              # 末尾に追加した新しい配列
%#nums                 # 要素数
```

## Option型

### リテラル

```
some(42)               # option<int>
none                   # option<unknown>
```

### 操作

| 構文 | 意味 | 備考 |
| ---- | ---- | ---- |
| `%opt?` | unwrap | noneならエラー |
| `%opt ^ default` | unwrap_or | noneならdefault |

### 環境変数との関係

環境変数は常に`option<string>`として取得される。
代入時は値が自動的に`some()`でラップされる。

```
$MY_VAR = "hello"      # 内部的には some("hello")
echo $MY_VAR?          # unwrapして "hello"
echo $MY_VAR ^ "default"  # 存在すれば値、なければ "default"
```

## 変数展開のコンテキスト

| コンテキスト | 変数展開 |
| ------------ | -------- |
| クォートなし | する |
| ダブルクォート | しない |
| シングルクォート | しない |
| raw文字列 | しない |
| パスリテラル | しない |

**補足**: 変数展開はクォートなしの場合のみ行われる。

## 単語分割

変数展開後の単語分割は行わない。

```
%var = "a b c"
echo %var              # 1引数として "a b c" を渡す
```

配列の場合は複数引数として展開される。

```
%files = ["a.txt", "b.txt", "c.txt"]
rm %files              # rm a.txt b.txt c.txt と同等
```

## 未定義変数

未定義変数の参照はエラーとする。

```
echo %undefined        # エラー: 未定義の変数 'undefined'
```

`$?VAR`や`%?VAR`で存在確認を行うことで安全にアクセスできる。

## 代入式の戻り値

代入式は`unit`型を返す。値は返さない。

```
echo (%x = 10)         # 何も出力しない
%y = (%x = 10)         # %y は unit 型、実質的に消える
```

---

# 付録

## 構文一覧

| 構文 | 用途 |
| ---- | ---- |
| `{ }` | コマンドグループ |
| `{{ }}` | サブシェル（別プロセスで実行） |
| `$( )` | コマンド展開（実行結果を文字列として取得） |
| `( )` | 式評価 |
| `&` | バックグラウンド実行（予約） |

## 実装ノート

### パーサ構造（参考）

```rust
pub enum Word {
    Literal(String),
    PathLiteral(String),
    EnvVar(EnvVarRef),
    ShellVar(ShellVarRef),
}

pub struct EnvVarRef {
    name: String,
    modifier: VarModifier,
}

pub struct ShellVarRef {
    name: String,
    type_annotation: Option<Type>,
    modifier: VarModifier,
}

pub enum VarModifier {
    None,                    // $VAR, %VAR
    Length,                  // $#VAR, %#VAR
    Exists,                  // $?VAR, %?VAR
    Unwrap,                  // $VAR?, %VAR?
    Default(Box<Word>),      // $VAR ^ default
}

pub enum Value {
    String(String),
    Int(i64),
    Float(f64),
    Bool(bool),
    Path(PathBuf),
    Array(Vec<Value>),
    Option(Option<Box<Value>>),
    Unit,
}
```
